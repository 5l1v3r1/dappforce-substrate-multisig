"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = withCall;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireDefault(require("react"));

var _util = require("@polkadot/util");

var _util2 = require("../util");

var _echo = _interopRequireDefault(require("../transform/echo"));

var _api = _interopRequireDefault(require("./api"));

// Copyright 2017-2019 @polkadot/ui-api authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const NOOP = () => {// ignore
};

function withCall(endpoint) {
  let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      at = _ref.at,
      atProp = _ref.atProp,
      callOnResult = _ref.callOnResult,
      _ref$params = _ref.params,
      params = _ref$params === void 0 ? [] : _ref$params,
      paramName = _ref.paramName,
      _ref$paramValid = _ref.paramValid,
      paramValid = _ref$paramValid === void 0 ? false : _ref$paramValid,
      propName = _ref.propName,
      _ref$transform = _ref.transform,
      transform = _ref$transform === void 0 ? _echo.default : _ref$transform;

  return Inner => {
    class WithPromise extends _react.default.Component {
      constructor(props) {
        super(props);
        this.state = {
          callResult: void 0,
          callUpdated: false,
          callUpdatedAt: 0
        };
        this.destroy = void 0;
        this.isActive = false;
        this.propName = void 0;
        this.timerId = -1;

        const _endpoint$split = endpoint.split('.'),
              _endpoint$split2 = (0, _slicedToArray2.default)(_endpoint$split, 3),
              section = _endpoint$split2[1],
              method = _endpoint$split2[2];

        this.propName = "".concat(section, "_").concat(method);
      }

      componentDidUpdate(prevProps) {
        const newParams = this.getParams(this.props);
        const oldParams = this.getParams(prevProps);

        if (this.isActive && !(0, _util2.isEqual)(newParams, oldParams)) {
          this.subscribe(newParams).then(NOOP).catch(NOOP);
        }
      }

      componentDidMount() {
        this.isActive = true;
        this.timerId = window.setInterval(() => {
          const elapsed = Date.now() - (this.state.callUpdatedAt || 0);
          const callUpdated = elapsed <= 1500;

          if (callUpdated !== this.state.callUpdated) {
            this.nextState({
              callUpdated
            });
          }
        }, 500);
        this.subscribe(this.getParams(this.props)).then(NOOP).catch(NOOP);
      }

      componentWillUnmount() {
        this.isActive = false;
        this.unsubscribe().then(NOOP).catch(NOOP);

        if (this.timerId !== -1) {
          clearInterval(this.timerId);
        }
      }

      nextState(state) {
        if (this.isActive) {
          this.setState(state);
        }
      }

      getParams(props) {
        const paramValue = paramName ? props[paramName] : undefined;

        if (atProp) {
          at = props[atProp];
        } // When we are specifying a param and have an invalid, don't use it. For 'params',
        // we default to the original types, i.e. no validation (query app uses this)


        if (!paramValid && paramName && ((0, _util.isUndefined)(paramValue) || (0, _util.isNull)(paramValue))) {
          return [false, []];
        }

        const values = (0, _util.isUndefined)(paramValue) ? params : params.concat(Array.isArray(paramValue) ? paramValue : [paramValue]);
        return [true, values];
      }

      getApiMethod(newParams) {
        const api = this.props.api;

        if (endpoint === 'subscribe') {
          const _newParams = (0, _toArray2.default)(newParams),
                fn = _newParams[0],
                params = _newParams.slice(1);

          return [fn, params, true];
        }

        const _endpoint$split3 = endpoint.split('.'),
              _endpoint$split4 = (0, _toArray2.default)(_endpoint$split3),
              area = _endpoint$split4[0],
              section = _endpoint$split4[1],
              method = _endpoint$split4[2],
              others = _endpoint$split4.slice(3);

        (0, _util.assert)(area.length && section.length && method.length && others.length === 0, "Invalid API format, expected <area>.<section>.<method>, found ".concat(endpoint));
        (0, _util.assert)(['rpc', 'query', 'derive'].includes(area), "Unknown api.".concat(area, ", expected rpc, query or derive"));
        (0, _util.assert)(!at || area === 'query', 'Only able todo an at query on the api.query interface');
        const apiSection = api[area][section];
        (0, _util.assert)(apiSection && apiSection[method], "Unable to find api.".concat(area, ".").concat(section, ".").concat(method));
        const meta = apiSection[method].meta;

        if (area === 'query' && meta && meta.type.isMap) {
          const arg = newParams[0];
          (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) || meta.type.asMap.isLinked, "".concat(meta.name, " expects one argument"));
        }

        return [apiSection[method], newParams, area === 'derive' || area === 'query' && !at && !atProp || method.startsWith('subscribe')];
      }

      async subscribe(_ref2) {
        let _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
            isValid = _ref3[0],
            newParams = _ref3[1];

        if (!isValid) {
          return;
        }

        const api = this.props.api;
        await api.isReady;

        try {
          const _this$getApiMethod = this.getApiMethod(newParams),
                _this$getApiMethod2 = (0, _slicedToArray2.default)(_this$getApiMethod, 3),
                apiMethod = _this$getApiMethod2[0],
                params = _this$getApiMethod2[1],
                isSubscription = _this$getApiMethod2[2];

          (0, _util.assert)(at || !atProp, 'Unable to perform query on non-existent at hash');
          await this.unsubscribe();

          if (isSubscription) {
            this.destroy = await apiMethod(...params, value => this.triggerUpdate(this.props, value));
          } else {
            const value = at ? await apiMethod.at(at, ...params) : await apiMethod(...params);
            this.triggerUpdate(this.props, value);
          }
        } catch (error) {// console.error(endpoint, '::', error);
        }
      }

      async unsubscribe() {
        if (this.destroy) {
          this.destroy();
          this.destroy = undefined;
        }
      }

      triggerUpdate(props, value) {
        try {
          const callResult = (props.transform || transform)(value);

          if (!this.isActive || (0, _util2.isEqual)(callResult, this.state.callResult)) {
            return;
          }

          (0, _util2.triggerChange)(callResult, callOnResult, props.callOnResult);
          this.nextState({
            callResult,
            callUpdated: true,
            callUpdatedAt: Date.now()
          });
        } catch (error) {// console.error(endpoint, '::', error.message);
        }
      }

      render() {
        const _this$state = this.state,
              callUpdated = _this$state.callUpdated,
              callUpdatedAt = _this$state.callUpdatedAt,
              callResult = _this$state.callResult;

        const _props = (0, _objectSpread2.default)({}, this.props, {
          callUpdated,
          callUpdatedAt,
          [propName || this.propName]: callResult
        });

        return _react.default.createElement(Inner, _props);
      }

    }

    return (0, _api.default)(WithPromise);
  };
}