"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _react = _interopRequireDefault(require("react"));

var _jsonrpc = _interopRequireDefault(require("@polkadot/jsonrpc"));

var _Context = require("./Context");

// Copyright 2017-2019 @polkadot/ui-app authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const defaultState = {
  stqueue: [],
  txqueue: []
};
let nextId = 0;
const REMOVE_TIMEOUT = 7500;
const SUBMIT_RPC = _jsonrpc.default.author.methods.submitAndWatchExtrinsic;
const STATUS_COMPLETE = [// status from subscription
'finalized', 'usurped', 'dropped', 'invalid', // normal completion
'cancelled', 'error', 'sent'];

class Queue extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = defaultState;

    this.queueAction = status => {
      const id = ++nextId;
      const removeItem = this.clearAction(id);
      this.setState(prevState => ({
        stqueue: prevState.stqueue.concat((0, _objectSpread2.default)({}, status, {
          id,
          isCompleted: false,
          removeItem
        }))
      }));
      setTimeout(removeItem, REMOVE_TIMEOUT);
      return id;
    };

    this.queueSetTxStatus = (id, status, result, error) => {
      this.setState(prevState => ({
        txqueue: prevState.txqueue.map(item => item.id === id ? (0, _objectSpread2.default)({}, item, {
          error: error === undefined ? item.error : error,
          result: result === undefined ? item.result : result,
          status: item.status === 'completed' ? item.status : status
        }) : item)
      }));
      this.addResultEvents(result);

      if (STATUS_COMPLETE.includes(status)) {
        setTimeout(this.clearStatus(id), REMOVE_TIMEOUT);
      }
    };

    this.queueAdd = value => {
      const id = ++nextId;
      const rpc = value.rpc || SUBMIT_RPC;
      const removeItem = this.clearStatus(id);
      this.setState(prevState => ({
        txqueue: prevState.txqueue.concat([(0, _objectSpread2.default)({}, value, {
          id,
          removeItem,
          rpc,
          status: 'queued'
        })])
      }));
      return id;
    };

    this.queueExtrinsic = (_ref) => {
      let accountId = _ref.accountId,
          extrinsic = _ref.extrinsic,
          signerCb = _ref.signerCb,
          signerOptions = _ref.signerOptions,
          txFailedCb = _ref.txFailedCb,
          txSuccessCb = _ref.txSuccessCb,
          txUpdateCb = _ref.txUpdateCb,
          isUnsigned = _ref.isUnsigned;
      return this.queueAdd({
        accountId,
        extrinsic,
        isUnsigned,
        signerCb,
        signerOptions,
        txFailedCb,
        txSuccessCb,
        txUpdateCb
      });
    };

    this.queueRpc = (_ref2) => {
      let accountId = _ref2.accountId,
          rpc = _ref2.rpc,
          values = _ref2.values;
      return this.queueAdd({
        accountId,
        rpc,
        values
      });
    };

    this.state = {
      stqueue: [],
      txqueue: [],
      queueAction: this.queueAction,
      queueRpc: this.queueRpc,
      queueExtrinsic: this.queueExtrinsic,
      queueSetTxStatus: this.queueSetTxStatus
    };
  }

  render() {
    return _react.default.createElement(_Context.QueueProvider, {
      value: this.state
    }, this.props.children);
  }

  clearAction(id) {
    return () => {
      this.setState(prevState => ({
        stqueue: prevState.stqueue.filter(item => item.id !== id)
      }));
    };
  }

  clearStatus(id) {
    return () => {
      this.setState(prevState => ({
        txqueue: prevState.txqueue.map(item => item.id === id ? (0, _objectSpread2.default)({}, item, {
          status: 'completed'
        }) : item)
      }));
    };
  }

  addResultEvents() {
    let _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$events = _ref3.events,
        events = _ref3$events === void 0 ? [] : _ref3$events;

    events.filter(record => record.event).forEach((_ref4) => {
      let _ref4$event = _ref4.event,
          method = _ref4$event.method,
          section = _ref4$event.section;

      // filter events handled globally, or those we are not interested in, these are
      // handled by the global overview, so don't add them here
      if (section === 'democracy') {
        return;
      }

      this.queueAction({
        action: "".concat(section, ".").concat(method),
        status: 'event',
        message: 'extrinsic event'
      });
    });
  }

}

exports.default = Queue;